<script context="module">
  export { load } from "./+page";
</script>

<script>
  import { onMount, onDestroy } from "svelte";
  import { pb } from "$lib/pocketbase";
  import { page } from "$app/stores"; // Import the page store to get the URL parameters
  import { goto } from "$app/navigation";
  import { browser } from "$app/environment"; // Import browser check

  // We'll use jsPDF instead of html2pdf
  let jsPDF;
  // Add a variable to store the custom font
  let customFont = null;

    export let data;
  
  let playlist = data.playlist;
  let song = playlist?.Songs?.[0]; // Assuming you want the first song
  let transposedLyrics = "";
    let keyOffset = 0;
  let showSongDetailsModal = false;
  let showPlaylistSelectionModal = false;
  let currentKey = "";
  let originalKey = "";
    let scale = 1;
  let loading = true;
  let playlists = []; // To hold the user's playlists
  let selectedPlaylistId = ""; // To hold the selected playlist ID
  let songId; // To hold the current song ID being saved
  let userId = "";
  let playlistSongs = []; // Will hold the full song objects
  let selectedSong = null;
  let showLyrics = false; // Changed to false by default
  let songTranspositions = {}; // Store transposition data for each song
  let errorMessage = ""; // Store error message if any
  let showPdfModal = false; // Control visibility of PDF generation modal
  let selectedTheme = "black"; // Default theme for PDF
  let isGeneratingPdf = false; // Flag to track PDF generation status
  let unsubscribeTranspositions = null;
  let unsubscribeSession = null; // For live session updates
  let openSongId = null; // Track which song is currently open
  let isLiveSession = false; // Track if we're in a live session
  let sessionId = null; // Store the session ID for updates
  let viewerCount = 0; // Track the number of viewers
  let unsubscribeViewers = null; // For viewer count updates
  let isViewer = false; // Track if this user is a viewer in the session
  let showShareModal = false; // Control visibility of share modal
  let shareLink = ""; // Store the share link
  let shareCopied = false; // Track if the link was copied
  let sessionLink = "";

  // Function to generate PDF with the selected theme
  async function generatePdf() {
    if (!browser) return;

    isGeneratingPdf = true;

    try {
      // Dynamically import jsPDF only when needed
      if (!jsPDF) {
        const module = await import("jspdf");
        jsPDF = module.jsPDF;

        // Import additional fonts for better text support
        try {
          await import("jspdf/dist/polyfills.es.js");
        } catch (error) {
          console.error("Error importing polyfills:", error);
        }
      }

      // Define page settings based on theme
      const pageOptions = {
        orientation: "portrait",
        unit: "mm",
        format: "a4",
      };

      // Create a new document
      const doc = new jsPDF(pageOptions);

      // Use a built-in font that supports Unicode
      doc.setFont("helvetica", "normal");

      // Define theme colors
      const primaryColor = selectedTheme === "black" ? "#7623ad" : "#333333";
      const textColor = selectedTheme === "black" ? "#ffffff" : "#000000";
      const backgroundColor = selectedTheme === "black" ? "#000000" : "#ffffff";
      const secondaryTextColor =
        selectedTheme === "black" ? "#aaaaaa" : "#666666";

      // Define font sizes - larger for black theme
      const titleFontSize = selectedTheme === "black" ? 24 : 16;
      const subtitleFontSize = selectedTheme === "black" ? 18 : 12;
      const keyFontSize = selectedTheme === "black" ? 16 : 10;
      const lyricsFontSize = selectedTheme === "black" ? 14 : 8;

      // Reduced line spacing multiplier
      const lineSpacingMultiplier = selectedTheme === "black" ? 0.5 : 0.25;

      // Set background color for the whole document
      if (selectedTheme === "black") {
        doc.setFillColor(backgroundColor);
        doc.rect(
          0,
          0,
          doc.internal.pageSize.getWidth(),
          doc.internal.pageSize.getHeight(),
          "F"
        );
      }

      // Add playlist title
      doc.setFontSize(titleFontSize);
      doc.setTextColor(primaryColor);
      doc.setFont("helvetica", "bold"); // Make title bold in both themes
      const playlistName = playlist.playlist_name;
      const margin = selectedTheme === "black" ? 20 : 15;
      doc.text(playlistName, margin, 25);

      // Add "Generated by PraisePoint" text
      doc.setFontSize(10);
      doc.setTextColor(selectedTheme === "black" ? "#aaaaaa" : "#666666");
      doc.setFont("helvetica", "italic");
      doc.text(
        "Generated by PraisePoint",
        margin,
        selectedTheme === "black" ? 35 : 40
      );

      // Add current key - only for black theme
      if (selectedTheme === "black") {
        doc.setFontSize(subtitleFontSize);
        doc.setTextColor(textColor);
        doc.setFont("helvetica", "normal");
        const keyText = `Current Key: ${currentKey}`;
        doc.text(keyText, margin, 45);
      }

      // Define margins and column layout
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const contentWidth = pageWidth - 2 * margin;

      // For black theme, use full width
      if (selectedTheme === "black") {
        const columnWidth = contentWidth;
        const maxWidth = columnWidth - 5; // Define maxWidth for black theme
        let currentY = 60; // Start position after title and key
        let currentPage = 1;

        // Process songs for black theme (single column)
        for (let i = 0; i < playlistSongs.length; i++) {
          const playlistSong = playlistSongs[i];

          // Reset Y position for new page
          if (currentY > pageHeight - margin) {
            doc.addPage();
            currentPage++;
            currentY = margin;

            // Set background color for new page if using black theme
            if (selectedTheme === "black") {
              doc.setFillColor(backgroundColor);
              doc.rect(
                0,
                0,
                doc.internal.pageSize.getWidth(),
                doc.internal.pageSize.getHeight(),
                "F"
              );
            }
          }

          // Get transposition data for this song
          let songKeyOffset = 0;
          let songTransposedLyrics = playlistSong.lyrics_chords || "";
          let songCurrentKey = playlistSong.key || "";

          if (songTranspositions[playlistSong.id]) {
            const transposition = songTranspositions[playlistSong.id];
            songKeyOffset = transposition.key_offset || 0;
            songTransposedLyrics =
              transposition.transposed_lyrics ||
              transposeText(playlistSong.lyrics_chords, songKeyOffset);

            // Calculate current key
            const { root } = splitChord(playlistSong.key || "");
            const idx = notes.indexOf(root);
            if (idx !== -1) {
              songCurrentKey =
                transposeNote(root, songKeyOffset) +
                (playlistSong.key || "").slice(root.length);
            }
          }

          // Add song title with special formatting for black theme
          doc.setFontSize(subtitleFontSize);
          if (selectedTheme === "black") {
            // Check if the title contains Sinhala characters
            const titleContainsSinhala = /[\u0D80-\u0DFF]/.test(
              playlistSong.title
            );

            if (titleContainsSinhala) {
              // For Sinhala title, use canvas rendering
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");

              // Set canvas size for title with higher resolution
              canvas.width = maxWidth * 10 * 2; // Double resolution
              canvas.height = subtitleFontSize * 8; // Increased height for vertical stretching

              // Set font and color
              ctx.font = `bold ${subtitleFontSize * 3}px Arial`; // Increased font size for vertical stretching
              ctx.fillStyle = "#000000"; // Black text for white theme

              // Draw title
              ctx.fillText(playlistSong.title, 15, subtitleFontSize * 2 + 10);

              // Convert to image and add to PDF with higher quality
              const imgData = canvas.toDataURL("image/png", 0.9);

              // Create a black background for song title in white theme
              doc.setFillColor(0, 0, 0);
              const titleWidth = maxWidth * 3;
              doc.rect(margin, currentY - 5, titleWidth + 6, 7, "F");

              // Add the title image
              doc.addImage(
                imgData,
                "PNG",
                margin + 3,
                currentY,
                titleWidth,
                subtitleFontSize * 3 // Increased height for vertical stretching
              );

              currentY += subtitleFontSize * 3 + 5; // Adjusted for taller text
            } else {
              // Bold purple titles in black theme
              doc.setFont("helvetica", "bold");
              doc.setTextColor(primaryColor);
              doc.text(playlistSong.title, margin, currentY);

              // Add transposed key next to the song title
              doc.setFontSize(keyFontSize);
              doc.setTextColor(secondaryTextColor);
              doc.setFont("helvetica", "normal");

              // Calculate the width of the title to position the key
              const titleWidth =
                doc.getStringUnitWidth(playlistSong.title) *
                (subtitleFontSize / doc.internal.scaleFactor);
              const keyString = `(${songCurrentKey})`;
              doc.text(keyString, margin + titleWidth + 5, currentY);

              doc.setFont("helvetica", "normal");
              currentY += 10;
            }
          } else {
            // Create a black background for song title in white theme
            doc.setFillColor(0, 0, 0);
            const titleWidth =
              doc.getStringUnitWidth(playlistSong.title) *
              (subtitleFontSize / doc.internal.scaleFactor);
            doc.rect(margin, currentY - 5, titleWidth + 6, 7, "F");
            doc.setTextColor(255, 255, 255); // White text on black background
            doc.text(playlistSong.title, margin + 3, currentY);
          }
          currentY += 10;

          // Add song key - only for black theme
          if (selectedTheme === "black") {
            // Skip this section as we've already added the key next to the title
          } else {
            doc.setFontSize(keyFontSize);
            doc.setTextColor(secondaryTextColor);
            const keyString = `Key: ${songCurrentKey}`;
            doc.text(keyString, margin, currentY);
            currentY += 8;
          }

          // Process and add lyrics
          doc.setFontSize(lyricsFontSize);
          doc.setTextColor(textColor);
          if (selectedTheme === "black") {
            doc.setFont("helvetica", "bold"); // Make lyrics bold in black theme
          }

          // Process song lyrics to handle chord notation and text wrapping
          const lyricsLines = songTransposedLyrics.split("\n");

          for (const line of lyricsLines) {
            // Check if we need to add a new page
            if (currentY > pageHeight - margin) {
              doc.addPage();
              currentPage++;
              currentY = margin;

              // Set background color for new page if using black theme
              if (selectedTheme === "black") {
                doc.setFillColor(backgroundColor);
                doc.rect(
                  0,
                  0,
                  doc.internal.pageSize.getWidth(),
                  doc.internal.pageSize.getHeight(),
                  "F"
                );
              }
            }

            // Process chord line (e.g., "[G]Hello [D]World")
            let processedLine = line;
            // Make chords (text inside []) bold or a different color
            if (line.includes("[") && line.includes("]")) {
              doc.setTextColor(primaryColor);
            }

            // For Sinhala text, we'll use a different approach
            // Check if the line contains Sinhala characters
            const containsSinhala = /[\u0D80-\u0DFF]/.test(line);

            if (containsSinhala) {
              // For Sinhala text, we'll use a different approach
              // We'll create a canvas element to render the text
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");

              // Increase canvas resolution to reduce pixelation
              const scaleFactor = 2; // Increased from 1 to 2 for better resolution
              canvas.width = maxWidth * 6 * scaleFactor;
              canvas.height = lyricsFontSize * 6 * scaleFactor; // Increased from 3 to 6 for vertical stretching

              // Scale the context to match the resolution
              ctx.scale(scaleFactor, scaleFactor);

              // Set font and color - use a taller font size to stretch vertically
              const fontSize = lyricsFontSize * 2.4; // Increased from 1.2 to 2.4 for vertical stretching
              ctx.font = `bold ${fontSize}px Arial`; // Use bold font for thickening
              ctx.fillStyle = selectedTheme === "black" ? "#ffffff" : "#000000";

              // Draw text with better positioning - adjusted for taller text
              ctx.fillText(processedLine, 15, fontSize + 2);

              // Convert canvas to image and add to PDF
              const imgData = canvas.toDataURL("image/png", 0.9); // Increased quality from 0.8 to 0.9
              // Stretch the image horizontally by a factor of 3.5
              doc.addImage(
                imgData,
                "PNG",
                margin,
                currentY,
                maxWidth * 3.5,
                fontSize * 0.8 // Increased from 0.4 to 0.8 for vertical stretching
              );

              // Update Y position with adjusted spacing for taller text
              currentY += fontSize * 0.8; // Increased from 0.4 to 0.8 for vertical stretching
            } else {
              // For non-Sinhala text, use the normal approach
              const textLines = doc.splitTextToSize(processedLine, maxWidth);
              doc.text(textLines, margin, currentY);
              // Reduce line spacing by using a smaller multiplier
              currentY +=
                textLines.length * (lyricsFontSize * lineSpacingMultiplier);
            }

            // Reset text color
            doc.setTextColor(textColor);

            // Add some space after each line
            if (selectedTheme === "black") {
              currentY += 1;
            } else {
              currentY += 2;
            }
          }

          // Add space between songs
          if (selectedTheme === "black") {
            currentY += 15;
          } else {
            currentY += 10;
          }

          // Add a separating line between songs if not the last song
          if (i < playlistSongs.length - 1) {
            if (selectedTheme === "black") {
              doc.setDrawColor(100, 100, 100);
              doc.setLineWidth(0.5);
            } else {
              doc.setDrawColor("#333333");
            }
            doc.line(
              margin,
              currentY - 5,
              margin + columnWidth - 10,
              currentY - 5
            );
          }
        }
      } else {
        // White theme - implement Word-style two-column layout
        const columnWidth = contentWidth / 2 - 5;
        const columnGap = 10;
        const xPositions = [margin, margin + columnWidth + columnGap];
        const maxWidth = columnWidth - 5; // Define maxWidth for white theme

        let currentY = selectedTheme === "black" ? 60 : 50; // Start position after title and key
        let currentPage = 1;
        let currentColumn = 0; // 0 for left column, 1 for right column

        // Process songs for white theme (two columns)
        for (let i = 0; i < playlistSongs.length; i++) {
          const playlistSong = playlistSongs[i];

          // Get transposition data for this song
          let songKeyOffset = 0;
          let songTransposedLyrics = playlistSong.lyrics_chords || "";
          let songCurrentKey = playlistSong.key || "";

          if (songTranspositions[playlistSong.id]) {
            const transposition = songTranspositions[playlistSong.id];
            songKeyOffset = transposition.key_offset || 0;
            songTransposedLyrics =
              transposition.transposed_lyrics ||
              transposeText(playlistSong.lyrics_chords, songKeyOffset);

            // Calculate current key
            const { root } = splitChord(playlistSong.key || "");
            const idx = notes.indexOf(root);
            if (idx !== -1) {
              songCurrentKey =
                transposeNote(root, songKeyOffset) +
                (playlistSong.key || "").slice(root.length);
            }
          }

          // Check if we need to start a new page
          if (currentY > pageHeight - margin) {
            doc.addPage();
            currentPage++;
            currentY = margin;
            currentColumn = 0; // Reset to first column on new page
          }

          // Add song title with special formatting for white theme
          doc.setFontSize(subtitleFontSize);
          if (selectedTheme === "white") {
            // Check if the title contains Sinhala characters
            const titleContainsSinhala = /[\u0D80-\u0DFF]/.test(
              playlistSong.title
            );

            if (titleContainsSinhala) {
              // For Sinhala title, use canvas rendering
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");

              // Set canvas size for title with higher resolution
              canvas.width = maxWidth * 10 * 2; // Double resolution
              canvas.height = subtitleFontSize * 8; // Increased height for vertical stretching

              // Set font and color
              ctx.font = `bold ${subtitleFontSize * 3}px Arial`; // Increased font size for vertical stretching
              ctx.fillStyle = "#000000"; // Black text for white theme

              // Draw title
              ctx.fillText(playlistSong.title, 15, subtitleFontSize * 2 + 10);

              // Convert to image and add to PDF with higher quality
              const imgData = canvas.toDataURL("image/png", 0.9);

              // Create a black background for song title in white theme
              doc.setFillColor(0, 0, 0);
              const titleWidth = maxWidth * 3;
              doc.rect(
                xPositions[currentColumn],
                currentY - 5,
                titleWidth + 6,
                7,
                "F"
              );

              // Add the title image
              doc.addImage(
                imgData,
                "PNG",
                xPositions[currentColumn] + 3,
                currentY,
                titleWidth,
                subtitleFontSize * 3 // Increased height for vertical stretching
              );

              currentY += subtitleFontSize * 3 + 5; // Adjusted for taller text
            } else {
              // Create a black background for song title in white theme
              doc.setFillColor(0, 0, 0);
              const titleWidth =
                doc.getStringUnitWidth(playlistSong.title) *
                (subtitleFontSize / doc.internal.scaleFactor);
              doc.rect(
                xPositions[currentColumn],
                currentY - 5,
                titleWidth + 6,
                7,
                "F"
              );
              doc.setTextColor(255, 255, 255); // White text on black background
              doc.text(
                playlistSong.title,
                xPositions[currentColumn] + 3,
                currentY
              );
              currentY += 8; // Increased spacing after song title
            }
          } else {
            doc.setTextColor(primaryColor);
            doc.text(playlistSong.title, xPositions[currentColumn], currentY);

            // Add transposed key next to the song title
            doc.setFontSize(keyFontSize);
            doc.setTextColor(secondaryTextColor);
            doc.setFont("helvetica", "normal");

            // Calculate the width of the title to position the key
            const titleWidth =
              doc.getStringUnitWidth(playlistSong.title) *
              (subtitleFontSize / doc.internal.scaleFactor);
            const keyString = `(${songCurrentKey})`;
            doc.text(
              keyString,
              xPositions[currentColumn] + titleWidth + 5,
              currentY
            );

            doc.setFont("helvetica", "normal");
          }
          currentY += 8; // Increased spacing after song title

          // Add song key - only for black theme
          if (selectedTheme === "black") {
            // Skip this section as we've already added the key next to the title
          } else {
            doc.setFontSize(keyFontSize);
            doc.setTextColor(secondaryTextColor);
            doc.text(
              `Key: ${songCurrentKey}`,
              xPositions[currentColumn],
              currentY
            );
            currentY += 6;
          }

          // Process and add lyrics
          doc.setFontSize(lyricsFontSize);
          doc.setTextColor(textColor);
          if (selectedTheme === "black") {
            doc.setFont("helvetica", "bold"); // Make lyrics bold in black theme
          }

          // Process song lyrics to handle chord notation and text wrapping
          const lyricsLines = songTransposedLyrics.split("\n");

          // Track if we need to continue in the next column
          let continueInNextColumn = false;

          for (const line of lyricsLines) {
            // Check if we need to add a new page or move to next column
            if (currentY > pageHeight - margin) {
              if (currentColumn === 0) {
                // Move to second column on same page
                currentColumn = 1;
                currentY = margin;
                continueInNextColumn = true;
              } else {
                // Add new page and reset to first column
                doc.addPage();
                currentPage++;
                currentColumn = 0;
                currentY = margin;
              }
            }

            // Process chord line (e.g., "[G]Hello [D]World")
            let processedLine = line;
            // Make chords (text inside []) bold or a different color
            if (line.includes("[") && line.includes("]")) {
              doc.setTextColor(primaryColor);
            }

            // For Sinhala text, we'll use a different approach
            // Check if the line contains Sinhala characters
            const containsSinhala = /[\u0D80-\u0DFF]/.test(line);

            if (containsSinhala) {
              // For Sinhala text, we'll use a different approach
              // We'll create a canvas element to render the text
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");

              // Increase canvas resolution to reduce pixelation
              const scaleFactor = 2; // Increased from 1 to 2 for better resolution
              canvas.width = maxWidth * 6 * scaleFactor;
              canvas.height = lyricsFontSize * 6 * scaleFactor; // Increased from 3 to 6 for vertical stretching

              // Scale the context to match the resolution
              ctx.scale(scaleFactor, scaleFactor);

              // Set font and color - use a taller font size to stretch vertically
              const fontSize = lyricsFontSize * 2.4; // Increased from 1.2 to 2.4 for vertical stretching
              ctx.font = `bold ${fontSize}px Arial`; // Use bold font for thickening
              ctx.fillStyle = selectedTheme === "black" ? "#ffffff" : "#000000";

              // Draw text with better positioning - adjusted for taller text
              ctx.fillText(processedLine, 15, fontSize + 2);

              // Convert canvas to image and add to PDF
              const imgData = canvas.toDataURL("image/png", 0.9); // Increased quality from 0.8 to 0.9
              // Stretch the image horizontally by a factor of 3.5
              doc.addImage(
                imgData,
                "PNG",
                xPositions[currentColumn],
                currentY,
                maxWidth * 3.5,
                fontSize * 0.8 // Increased from 0.4 to 0.8 for vertical stretching
              );

              // Update Y position with adjusted spacing for taller text
              currentY += fontSize * 0.8; // Increased from 0.4 to 0.8 for vertical stretching
            } else {
              // For non-Sinhala text, use the normal approach
              const textLines = doc.splitTextToSize(processedLine, maxWidth);
              doc.text(textLines, xPositions[currentColumn], currentY);
              // Reduce line spacing by using a smaller multiplier
              currentY +=
                textLines.length * (lyricsFontSize * lineSpacingMultiplier);
            }

            // Reset text color
            doc.setTextColor(textColor);

            // Add some space after each line
            currentY += selectedTheme === "black" ? 1 : 3; // Increased spacing for white theme
          }

          // Add space between songs
          currentY += selectedTheme === "black" ? 15 : 12; // Increased spacing for white theme

          // Add a separating line between songs
          if (i < playlistSongs.length - 1) {
            doc.setDrawColor("#cccccc");
            doc.line(
              xPositions[currentColumn],
              currentY - 5,
              xPositions[currentColumn] + columnWidth,
              currentY - 5
            );
          }

          // If we continued in the next column, stay there for the next song
          // Otherwise, move to the next column if available
          if (
            !continueInNextColumn &&
            currentColumn === 0 &&
            i < playlistSongs.length - 1
          ) {
            currentColumn = 1;
            currentY = margin;
          }
        }
      }

      // Generate filename
      const filename = `${playlist.playlist_name.replace(/\s+/g, "_")}_${selectedTheme}.pdf`;

      // Save the PDF
      doc.save(filename);

      // Close the modal
      closePdfModal();
    } catch (error) {
      console.error("Error generating PDF:", error);
    } finally {
      isGeneratingPdf = false;
    }
  }

  // Load song data and transposition information
  onMount(async () => {
    // Dynamically import jsPDF when in the browser
    if (browser) {
      try {
        const module = await import("jspdf");
        jsPDF = module.jsPDF;
      } catch (e) {
        console.error("Failed to load jsPDF:", e);
      }
    }

    try {
      // Get the current user
      const user = pb.authStore.model;
      if (user) {
        userId = user.id;
      }

      // Check if we have an error from the server
      if (data.error) {
        errorMessage = data.error.message || "An error occurred";
        loading = false;
        return;
      }

      // Fetch the playlist with expanded Songs relation
      const { id } = $page.params;
      playlist = await pb.collection("playlists").getOne(id, {
        expand: "Songs",
      });
      console.log("Fetched playlist:", playlist);

      // Fetch all songs in the playlist
      if (playlist.Songs && playlist.Songs.length > 0) {
        const songPromises = playlist.Songs.map((songId) =>
          pb.collection("songs").getOne(songId)
        );
        playlistSongs = await Promise.all(songPromises);
        console.log("Fetched songs:", playlistSongs);

        // Set the first song as the current song
        if (playlistSongs.length > 0) {
          song = playlistSongs[0];
          originalKey = song.key || "";
          currentKey = originalKey;
          transposedLyrics = song.lyrics_chords || "";
        }
      }

      // Fetch transposition data for all songs in the playlist
      if (playlistSongs.length > 0) {
        const transpositionPromises = playlistSongs.map(
          (song) =>
            pb
              .collection("song_transpositions")
              .getFirstListItem(
                `song = "${song.id}" && playlist = "${playlist.id}"`
              )
              .catch(() => null) // If no transposition exists, return null
        );

        const transpositions = await Promise.all(transpositionPromises);

        // Create a map of song ID to transposition data
        transpositions.forEach((transposition) => {
          if (transposition) {
            songTranspositions[transposition.song] = transposition;
          }
        });

        console.log("Fetched transpositions:", songTranspositions);

        // Apply transposition to the current song if it exists
        if (song && songTranspositions[song.id]) {
          const transposition = songTranspositions[song.id];
          keyOffset = transposition.key_offset || 0;
          transposedLyrics = transposeText(song.lyrics_chords, keyOffset);
          currentKey = getCurrentKey();
        }
      }

      // Check if we're joining a live session from a shared link
      const isLiveSessionLink =
        browser &&
        new URL(window.location.href).searchParams.get("live") === "true";

      // Fetch the current session data for this playlist
      try {
        // Only fetch session data if the playlist is public
        if (!playlist.field.includes("Private")) {
          // Instead of creating/updating sessions directly, we'll use a different approach
          // We'll use the playlist's metadata field to store session information
          // This avoids permission issues with the playlist_sessions collection

          // Check if the playlist has a metadata field with session info
          if (playlist.metadata && playlist.metadata.session) {
            const sessionData = playlist.metadata.session;
            openSongId = sessionData.open_song;
            isLiveSession = true;
            viewerCount = sessionData.viewers || 0;

            // If there's an open song in the session, select it
            if (openSongId) {
              const openSong = playlistSongs.find((s) => s.id === openSongId);
              if (openSong) {
                song = openSong;
                originalKey = song.key || "";
                showLyrics = true;

                // Apply transposition if available
                if (songTranspositions[song.id]) {
                  const transposition = songTranspositions[song.id];
                  keyOffset = transposition.key_offset || 0;
                  transposedLyrics = transposeText(
                    song.lyrics_chords,
                    keyOffset
                  );
                } else {
                  keyOffset = 0;
                  transposedLyrics = song.lyrics_chords || "";
                }

                currentKey = getCurrentKey();
              }
            }

            // Join the live session as a viewer
            await joinLiveSession();
          } else if (isLiveSessionLink) {
            // If we're coming from a live session link but there's no active session,
            // we should show a message that the session has ended
            console.log(
              "Live session link detected but no active session found"
            );
            // We could add a notification here if desired
          }
        } else if (isLiveSessionLink) {
          // If we're coming from a live session link but the playlist is private,
          // we should show a message that live sessions are only available for public playlists
          console.log("Live session link detected but playlist is private");
          // We could add a notification here if desired
        }
      } catch (error) {
        console.error("Error fetching session data:", error);
      }

      // Function to set up real-time subscriptions
      function setupSubscriptions() {
        if (!playlist) return;

        // Subscribe to transposition updates
        try {
          unsubscribeTranspositions = pb
            .collection("song_transpositions")
            .subscribe(
              "*",
              function (e) {
                console.log("Transposition update:", e.action, e.record);

                // Only process updates for songs in this playlist
                if (e.record.playlist === playlist.id) {
                  const songId = e.record.song;

                  // Update the transposition in our local state
                  if (e.action === "create" || e.action === "update") {
                    songTranspositions[songId] = e.record;

                    // If this is the currently selected song, update the display
                    if (selectedSong && selectedSong.id === songId) {
                      keyOffset = e.record.key_offset || 0;
                      transposedLyrics = transposeText(
                        selectedSong.lyrics_chords,
                        keyOffset
                      );
                      currentKey = getCurrentKey();
                    }
                  } else if (e.action === "delete") {
                    // Remove the transposition from our local state
                    delete songTranspositions[songId];

                    // If this is the currently selected song, reset to original key
                    if (selectedSong && selectedSong.id === songId) {
                      keyOffset = 0;
                      transposedLyrics = selectedSong.lyrics_chords || "";
                      currentKey = originalKey;
                    }
                  }
                }
              },
              {
                filter: `playlist = "${playlist.id}"`,
              }
            );
        } catch (error) {
          console.error("Error setting up transposition subscription:", error);
        }

        // Subscribe to session updates if we're in a live session
        if (isLiveSession && sessionId) {
          try {
            unsubscribeSession = pb
              .collection("playlist_sessions")
              .subscribe(sessionId, function (e) {
                console.log("Session update:", e.action, e.record);

                if (e.action === "update") {
                  // Update the open song ID
                  openSongId = e.record.open_song;
                  viewerCount = e.record.viewerCount || 0;

                  // If the open song is different from the current song, update it
                  if (
                    openSongId &&
                    (!selectedSong || selectedSong.id !== openSongId)
                  ) {
                    const openSong = playlistSongs.find(
                      (s) => s.id === openSongId
                    );
                    if (openSong) {
                      selectSong(openSong);
                    }
                  } else if (!openSongId) {
                    // If no song is open in the session, close the lyrics
                    showLyrics = false;
                  }
                } else if (e.action === "delete") {
                  // Session has ended
                  isLiveSession = false;
                  sessionId = null;
                  sessionLink = "";
                  viewerCount = 0;
                  isViewer = false;
                }
              });
          } catch (error) {
            console.error("Error setting up session subscription:", error);
          }
        }
      }
    } catch (error) {
      console.error("Error loading playlist data:", error);
      errorMessage =
        error.message || "An error occurred while loading the playlist";
    } finally {
      loading = false;
    }
  });

  // Clean up subscriptions when component is destroyed
  onDestroy(() => {
    if (
      unsubscribeTranspositions &&
      typeof unsubscribeTranspositions === "function"
    ) {
      unsubscribeTranspositions();
    }
    if (unsubscribeSession && typeof unsubscribeSession === "function") {
      unsubscribeSession();
    }
    if (unsubscribeViewers && typeof unsubscribeViewers === "function") {
      unsubscribeViewers();
    }

    // Leave the live session when the component is destroyed
    if (isViewer) {
      leaveLiveSession();
    }
  });
  
    // Process YouTube links for embedding
    $: embedUrls = [song?.links, song?.link2]
      .filter(Boolean)
    .map((link) => {
        try {
          const url = new URL(link.trim());
          if (url.hostname.includes("youtu.be")) {
            return `https://www.youtube.com/embed/${url.pathname.slice(1)}`;
          }
          if (url.hostname.includes("youtube.com") && url.searchParams.has("v")) {
            const videoId = url.searchParams.get("v");
            return `https://www.youtube.com/embed/${videoId}`;
          }
        } catch (err) {
          console.error("Invalid YouTube link:", link);
        }
        return null;
      })
      .filter(Boolean);
  
  const notes = [
    "C",
    "C#",
    "D",
    "D#",
    "E",
    "F",
    "F#",
    "G",
    "G#",
    "A",
    "A#",
    "B",
  ];
  
    function transposeNote(note, offset) {
      const idx = notes.indexOf(note);
      if (idx === -1) return note;
      return notes[(idx + offset + notes.length) % notes.length];
    }
  
    function splitChord(chord) {
      const match = chord.match(/^([A-G](?:#|b)?)(.*)$/);
      if (!match) return { root: chord, quality: "" };
      return { root: match[1], quality: match[2] };
    }
  
    function transposeChord(chord, offset) {
      if (chord.includes("/")) {
        const parts = chord.split("/");
      return (
        transposeChord(parts[0], offset) +
        "/" +
        transposeChord(parts[1], offset)
      );
      }
      const { root, quality } = splitChord(chord);
      return transposeNote(root, offset) + quality;
    }
  
    function isChord(token) {
    return /^[A-G](?:#|b)?(?:m|maj|min|dim|aug|sus|add)?\d*(?:\/[A-G](?:#|b)?(?:m|maj|min|dim|aug|sus|add)?\d*)?$/.test(
      token
    );
    }
  
    function transposeText(text, offset) {
      return text
        .split(/(\s+)/)
      .map((token) => (isChord(token) ? transposeChord(token, offset) : token))
      .join("");
    }
  
    function getCurrentKey() {
      const parts = originalKey.split(" ");
      const root = parts[0];
      const suffix = parts.slice(1).join(" ");
      const idx = notes.indexOf(root);
      if (idx === -1) return originalKey;
    return (
      notes[(idx + keyOffset + notes.length) % notes.length] +
      (suffix ? " " + suffix : "")
    );
  }

  function changeKey(offset) {
    keyOffset += offset;
    if (song) {
      transposedLyrics = transposeText(song.lyrics_chords, keyOffset);
      currentKey = getCurrentKey();

      // Save the transposition to the database
      saveTransposition();
    }
  }

  async function saveTransposition() {
    if (!song || !playlist) return;

    try {
      // Check if a transposition already exists for this song
      const existingTransposition = await pb
        .collection("song_transpositions")
        .getFirstListItem(`song = "${song.id}" && playlist = "${playlist.id}"`)
        .catch(() => null);

      if (existingTransposition) {
        // Update the existing transposition
        await pb
          .collection("song_transpositions")
          .update(existingTransposition.id, {
            key_offset: keyOffset,
          });
        console.log("Transposition updated:", existingTransposition.id);
      } else {
        // Create a new transposition
        const newTransposition = await pb
          .collection("song_transpositions")
          .create({
            song: song.id,
            playlist: playlist.id,
            key_offset: keyOffset,
            user: userId,
          });
        console.log("New transposition created:", newTransposition);
      }
    } catch (error) {
      console.error("Error saving transposition:", error);
    }
  }

  function openPlaylistSelectionModal(id) {
    songId = id;
    showPlaylistSelectionModal = true;
  }

  function closePlaylistSelectionModal() {
    showPlaylistSelectionModal = false;
    selectedPlaylistId = "";
    }
  
    function zoomIn() {
      scale += 0.1;
    }
  
    function zoomOut() {
      if (scale > 0.5) scale -= 0.1;
    }

  function toggleLyrics() {
    showLyrics = !showLyrics;
  }

  // Function to select a song from the playlist
  async function selectSong(songId) {
    const selectedSong = playlistSongs.find((s) => s.id === songId);
    if (selectedSong) {
      // Toggle lyrics visibility if the same song is clicked again
      if (song && song.id === songId) {
        showLyrics = !showLyrics;

        // Update the session
        if (isLiveSession && !playlist.field.includes("Private")) {
          try {
            console.log(
              "Updating session with open_song:",
              showLyrics ? songId : null
            );
            // Update the playlist_sessions collection
            await pb.collection("playlist_sessions").update(sessionId, {
              open_song: showLyrics ? songId : null,
              updated: new Date().toISOString(),
            });
          } catch (error) {
            console.error("Error updating session:", error);
          }
        }

        return;
      }

      // Otherwise, select the new song and show lyrics
      song = selectedSong;
      originalKey = song.key || "";
      showLyrics = true; // Show lyrics when a new song is selected

      // Check if we have transposition data for this song
      if (songTranspositions[song.id]) {
        const transposition = songTranspositions[song.id];
        keyOffset = transposition.key_offset || 0;
        transposedLyrics = transposeText(song.lyrics_chords, keyOffset);
      } else {
        // No transposition data, use original lyrics
        keyOffset = 0;
        transposedLyrics = song.lyrics_chords || "";
      }

      currentKey = getCurrentKey();

      // Update the session
      if (isLiveSession && !playlist.field.includes("Private")) {
        try {
          console.log("Updating session with open_song:", songId);
          // Update the playlist_sessions collection
          await pb.collection("playlist_sessions").update(sessionId, {
            open_song: songId,
            updated: new Date().toISOString(),
          });
        } catch (error) {
          console.error("Error updating session:", error);
        }
      }
    }
  }

  async function navigateToPlaylist(playlistId) {
    await goto(`/playlists/${playlistId}`);
  }

  // Function to open the modal
  function openSongDetailsModal(songId) {
    selectedSong = playlistSongs.find((song) => song.id === songId);
    showSongDetailsModal = true;
  }

  // Function to close the modal
  function closeSongDetailsModal() {
    showSongDetailsModal = false; // Hide the modal
    selectedPlaylistId = ""; // Reset the selected playlist
  }

  // Function to save the song to the selected playlist
  async function saveSongToPlaylist() {
    if (!selectedPlaylistId) {
      console.error("No playlist selected.");
      return;
    }

    try {
      const playlist = await pb
        .collection("playlists")
        .getOne(selectedPlaylistId);
      playlist.Songs.push(songId); // Add the song ID to the playlist's Songs array
      await pb.collection("playlists").update(selectedPlaylistId, playlist); // Update the playlist in PocketBase

      // Save the current transposition data for this song in this playlist
      if (songTranspositions[songId]) {
        const transposition = songTranspositions[songId];
        await pb.collection("song_transpositions").create({
          song: songId,
          playlist: selectedPlaylistId,
          key_offset: transposition.key_offset || 0,
          user: userId,
        });
      }

      console.log("Song added to playlist:", playlist);
      closeSongDetailsModal(); // Close the modal after saving
    } catch (error) {
      console.error("Error saving song to playlist:", error);
    }
  }

  async function removeSong(playlist, songId) {
    // Create a copy of the playlist's Songs array without the songId
    playlist.Songs = playlist.Songs.filter((id) => id !== songId);

    try {
      await pb.collection("playlists").update(playlist.id, {
        Songs: playlist.Songs,
      });
      console.log("Song removed from playlist");

      // Update the displayed songs list
      playlistSongs = playlistSongs.filter((song) => song.id !== songId);
    } catch (error) {
      console.error("Error removing song:", error);
    }
  }

  // Function to open the PDF generation modal
  function openPdfModal() {
    showPdfModal = true;
  }

  // Function to close the PDF generation modal
  function closePdfModal() {
    showPdfModal = false;
  }

  // Function to toggle live session
  async function toggleLiveSession() {
    try {
      if (!isLiveSession) {
        // Check if playlist is public
        if (playlist.field.includes("Private")) {
          alert("This playlist must be public to start a live session");
          return;
        }

        // Create a new session
        const sessionData = {
          playlist: playlist.id,
          open_song: selectedSong?.id || null,
          user: userId || "anonymous",
          viewerCount: 0,
          created: new Date().toISOString(),
          updated: new Date().toISOString(),
        };

        console.log("Creating new session:", sessionData);
        const session = await pb
          .collection("playlist_sessions")
          .create(sessionData);
        sessionId = session.id;
        sessionLink = `${window.location.origin}/live/${sessionId}`;

        // Update the session with the link
        await pb.collection("playlist_sessions").update(sessionId, {
          link: sessionLink,
        });

        isLiveSession = true;
        viewerCount = 0;
        isViewer = false; // Creator is not a viewer

        console.log("Session created successfully:", sessionId);
      } else {
        // End the session
        if (sessionId) {
          console.log("Ending session:", sessionId);
          await pb.collection("playlist_sessions").delete(sessionId);
          sessionId = null;
          sessionLink = "";
        }
        isLiveSession = false;
        viewerCount = 0;
        isViewer = false;
      }
    } catch (err) {
      console.error("Error toggling live session:", err);
      alert("Failed to toggle live session. Please try again.");
    }
  }

  // Function to join a live session as a viewer
  async function joinLiveSession() {
    if (!playlist || playlist.field.includes("Private")) return;

    try {
      // Update the session to increment the viewer count
      const session = await pb
        .collection("playlist_sessions")
        .getOne(sessionId);
      const currentViewerCount = session.viewerCount || 0;

      await pb.collection("playlist_sessions").update(sessionId, {
        viewerCount: currentViewerCount + 1,
        updated: new Date().toISOString(),
      });

      // Mark this user as a viewer
      isViewer = true;
      viewerCount = currentViewerCount + 1;

      console.log("Joined live session as viewer. Total viewers:", viewerCount);
    } catch (error) {
      console.error("Error joining live session:", error);
    }
  }

  // Function to leave a live session
  async function leaveLiveSession() {
    if (!playlist || !isViewer) return;

    try {
      // Update the session to decrement the viewer count
      const session = await pb
        .collection("playlist_sessions")
        .getOne(sessionId);
      const currentViewerCount = session.viewerCount || 1;

      await pb.collection("playlist_sessions").update(sessionId, {
        viewerCount: Math.max(0, currentViewerCount - 1),
        updated: new Date().toISOString(),
      });

      // Mark this user as no longer a viewer
      isViewer = false;
      viewerCount = Math.max(0, currentViewerCount - 1);

      console.log("Left live session. Remaining viewers:", viewerCount);
    } catch (error) {
      console.error("Error leaving live session:", error);
    }
  }

  // Function to generate a share link for the live session
  function generateShareLink() {
    if (browser) {
      // Always use the session link if available
      if (sessionLink) {
        shareLink = sessionLink;
      } else {
        // Fallback to playlist link with live parameter
        const url = window.location.href;
        const shareUrl = new URL(url);
        shareUrl.searchParams.set("live", "true");
        shareLink = shareUrl.toString();
      }
    }
  }

  // Function to open the share modal
  function openShareModal() {
    generateShareLink();
    showShareModal = true;
  }

  // Function to close the share modal
  function closeShareModal() {
    showShareModal = false;
    shareCopied = false;
  }

  // Function to copy the share link to clipboard
  async function copyShareLink() {
    if (browser) {
      try {
        await navigator.clipboard.writeText(shareLink);
        shareCopied = true;

        // Reset the copied state after 2 seconds
        setTimeout(() => {
          shareCopied = false;
        }, 2000);
      } catch (error) {
        console.error("Error copying to clipboard:", error);
      }
    }
  }

  // Function to transpose the key
  async function transposeKey(offset) {
    if (!song) return;

    // Calculate the new key offset
    const newKeyOffset = keyOffset + offset;

    // Create or update the transposition record
    try {
      // Check if we already have a transposition for this song
      const existingTransposition = Object.values(songTranspositions).find(
        (t) => t.song === song.id && t.playlist === playlist.id
      );

      if (existingTransposition) {
        // Update the existing transposition
        await pb
          .collection("song_transpositions")
          .update(existingTransposition.id, {
            key_offset: newKeyOffset,
            updated: new Date().toISOString(),
          });
      } else {
        // Create a new transposition
        await pb.collection("song_transpositions").create({
          song: song.id,
          playlist: playlist.id,
          key_offset: newKeyOffset,
          created: new Date().toISOString(),
          updated: new Date().toISOString(),
        });
      }

      // Update the local state
      keyOffset = newKeyOffset;
      transposedLyrics = transposeText(song.lyrics_chords, keyOffset);
      currentKey = getCurrentKey();

      // Update the session if in live mode
      if (isLiveSession && !playlist.field.includes("Private")) {
        try {
          // Update the playlist_sessions collection
          await pb.collection("playlist_sessions").update(sessionId, {
            open_song: song.id,
            updated: new Date().toISOString(),
          });
        } catch (error) {
          console.error("Error updating session:", error);
        }
      }
    } catch (error) {
      console.error("Error transposing key:", error);
      alert("Failed to transpose key. Please try again.");
    }
  }
  </script>
  
{#if loading}
  <div class="flex justify-center items-center min-h-[200px]">
    <p class="text-white text-lg">Loading playlist details...</p>
  </div>
{:else if errorMessage}
  <div
    class="flex flex-col items-center justify-center min-h-[300px] text-center p-8 bg-gray-900 rounded-lg m-8 max-w-2xl mx-auto"
  >
    <h2 class="text-red-400 text-2xl font-bold mb-4">Access Denied</h2>
    <p class="text-white text-lg mb-8">{errorMessage}</p>
    <a
      href="/playlists"
      class="bg-[#7623ad] text-white px-6 py-3 rounded-lg font-bold hover:bg-[#5a1a8a] transition duration-300"
    >
      Back to My Playlists
    </a>
  </div>
{:else if playlist}
  <div class="min-h-screen bg-gray-950 text-white p-4">
    <div class="container mx-auto max-w-6xl">
      <div class="bg-gray-900/50 rounded-xl shadow-lg p-4 mb-4">
        <h1 class="text-2xl font-bold mb-4 text-[#ffffff]">
          {playlist.playlist_name}
      </h1>
        <p class="mb-4 text-gray-300">
          Visibility: {playlist.field.includes("Private")
            ? "Private"
            : "Public"}
        </p>

        <div class="flex justify-between items-center mt-4">
          {#if !playlist.field.includes("Private")}
            <div class="flex items-center gap-4">
              <div class="flex items-center gap-2">
                <button
                  class="px-3 py-1 rounded-md text-sm font-medium transition-colors {isLiveSession
                    ? 'bg-red-500 hover:bg-red-600 text-white'
                    : 'bg-blue-500 hover:bg-blue-600 text-white'}"
                  on:click={toggleLiveSession}
                >
                  {isLiveSession ? "End Live Session" : "Start Live Session"}
                </button>

                {#if isLiveSession}
                  <div class="flex items-center gap-2">
                    <span class="text-sm text-gray-400"
                      >Viewers: {viewerCount}</span
                    >
                    <div class="flex items-center gap-1">
                      <input
                        type="text"
                        value={sessionLink}
                        readonly
                        class="px-2 py-1 bg-gray-800 text-gray-300 rounded text-sm w-64"
                      />
                      <button
                        class="px-2 py-1 bg-gray-700 hover:bg-gray-600 text-gray-300 rounded text-sm"
                        on:click={() => {
                          navigator.clipboard.writeText(sessionLink);
                          alert("Link copied to clipboard!");
                        }}
                      >
                        Copy
                      </button>
                    </div>
                  </div>
                {/if}
              </div>

              {#if isLiveSession}
                <button
                  on:click={openShareModal}
                  class="flex items-center gap-2 bg-blue-700 hover:bg-blue-800 text-white px-4 py-2 rounded-lg font-bold transition duration-300"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"
                    />
          </svg>
                  Share
        </button>
              {/if}
            </div>
          {:else}
            <div class="text-gray-400 text-sm">
              Live sessions are only available for public playlists
            </div>
          {/if}

          <button
            on:click={openPdfModal}
            class="bg-[#7623ad] text-white px-4 py-2 rounded-lg font-bold hover:bg-[#5a1a8a] transition duration-300"
          >
            Generate PDF
          </button>
        </div>
      </div>

      <h2 class="text-xl font-bold mb-4 text-[#86b0ff]">Songs</h2>
      <ul class="space-y-2">
        {#each playlistSongs as playlistSong}
          <li class="bg-gray-900/50 rounded-lg overflow-hidden">
            <div
              class="p-4 flex justify-between items-center cursor-pointer hover:bg-gray-950/25 transition-colors"
              
            >
              <div class="flex-1"
              on:click={() => selectSong(playlistSong.id)}
              >
                <span class="text-lg font-medium"
                
                >{playlistSong.title}

                  
                </span>
              </div>
              <div class="flex items-center gap-4"
              
              >
                <div
                  class="flex items-center gap-2 bg-indigo-900/25 px-3 py-1.5 rounded-lg"
                >
                  <span class="text-[#7c90ff] font-bold">
                    {#if songTranspositions[playlistSong.id]}
                      {transposeNote(
                        splitChord(playlistSong.key || "").root,
                        songTranspositions[playlistSong.id].key_offset || 0
                      ) +
                        (playlistSong.key || "").slice(
                          splitChord(playlistSong.key || "").root.length
                        )}
                    {:else}
                      {playlistSong.key || "No key"}
                    {/if}
                  </span>
                  <div class="flex gap-1">
                    <button
                      on:click|stopPropagation={() => {
                        
                        transposeKey(-1);
                      }}
                      class="bg-indigo-900 text-white w-6 h-6 rounded-full flex items-center justify-center hover:bg-indigo-800 transition duration-300"
                      title="Lower Key"
                    >
                      <svg
                        class="w-4 h-4"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        xmlns="http://www.w3.org/2000/svg"
                      >
                        <path
                          d="M6 12L18 12"
                          stroke-width="2"
                          stroke-linecap="round"
                          stroke-linejoin="round"
                        />
                      </svg>
                    </button>
                    <button
                      on:click|stopPropagation={() => {
                        
                        transposeKey(1);
                      }}
                      class="bg-indigo-900 text-white w-6 h-6 rounded-full flex items-center justify-center hover:bg-indigo-800 transition duration-300"
                      title="Raise Key"
                    >
                      <svg
                        class="w-4 h-4"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        xmlns="http://www.w3.org/2000/svg"
                      >
                        <path
                          d="M6 12H18M12 6V18"
                          stroke-width="2"
                          stroke-linecap="round"
                          stroke-linejoin="round"
                        />
          </svg>
        </button>
                  </div>
                </div>
                <div class="flex gap-2">
                  <button
                    on:click|stopPropagation={() =>
                      openSongDetailsModal(playlistSong.id)}
                    class="bg-[#125a1c] text-white w-8 h-8 rounded-full flex items-center justify-center hover:bg-[#14641f] transition duration-300"
                    title="Details"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      class="h-5 w-5"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                    >
                      <path
                        d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z"
                      />
                    </svg>
                  </button>
                  <button
                    on:click|stopPropagation={() =>
                      removeSong(playlist, playlistSong.id)}
                    class="bg-red-900 text-white w-8 h-8 rounded-full flex items-center justify-center hover:bg-red-800 transition duration-300"
                    title="Remove"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      class="h-5 w-5"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                    >
                      <path
                        fill-rule="evenodd"
                        d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                        clip-rule="evenodd"
                      />
                    </svg>
                  </button>
                </div>
              </div>
      </div>
  
            {#if song && song.id === playlistSong.id && showLyrics}
              <div class="bg-gray-700 p-4 border-t border-gray-600">
                <div class="flex justify-between items-center mb-2">
                  <p class="text-gray-300">Original Key: {originalKey}</p>
                  <p class="text-gray-300">Current Key: {currentKey}</p>
      </div>
  
                <div class="bg-black rounded-lg p-4">
                  <pre
                    class="font-['Abel'] text-white whitespace-pre-wrap text-lg">{transposedLyrics}</pre>
      </div>
    </div>
            {/if}
          </li>
        {/each}
      </ul>
    </div>
  </div>
{:else}
  <p class="text-center text-red-500 mt-6">
    Playlist not found. Please check the URL.
  </p>
{/if}

{#if showSongDetailsModal && selectedSong}
  <div
    class="fixed inset-0 bg-black/75 bg-opacity-80 flex justify-center items-center z-50"
    on:click={closeSongDetailsModal}
  >
    <div
      class="bg-gray-900 p-6 rounded-lg w-11/12 max-w-2xl"
      on:click|stopPropagation
    >
      <div class="flex justify-between items-center mb-2">
        <h1 class="text-xl font-bold text-[#ffffff]">{selectedSong.title}</h1>
        <button
          class="text-gray-400 hover:text-white text-2xl"
          on:click={closeSongDetailsModal}>&times;</button
        >
      </div>
      <p class="text-gray-300 mb-2">
        Artist: {selectedSong.artist || "Unknown Artist"}
      </p>
      <h2 class="text-white mb-4">YouTube Video:</h2>
          {#if embedUrls.length > 0}
        <div class="grid gap-4">
              {#each embedUrls as url}
            <div class="relative w-full pb-[56.25%] h-0">
                  <iframe
                class="absolute top-0 left-0 w-full h-full rounded-lg shadow-lg"
                    src={url}
                    frameborder="0"
                    allow="autoplay; encrypted-media"
                    allowfullscreen
                  ></iframe>
                </div>
              {/each}
            </div>
          {:else}
            <p class="text-gray-400">No video links provided.</p>
          {/if}
        </div>
      </div>
    {/if}

<!-- Modal for selecting a playlist -->
{#if showPlaylistSelectionModal}
  <div
    class="fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-50"
    on:click={closePlaylistSelectionModal}
  >
    <div
      class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md"
      on:click|stopPropagation
    >
      <h2 class="text-xl font-bold mb-4 text-[#7623ad]">Select a Playlist</h2>
      {#if userId}
        <!-- Check if the user is signed in -->
        <ul class="space-y-2 mb-4">
          {#each playlists as playlist}
            <li class="flex items-center">
              <label class="flex items-center gap-2 cursor-pointer">
                <input
                  type="radio"
                  bind:group={selectedPlaylistId}
                  value={playlist.id}
                  class="text-[#7623ad]"
                />
                <span>{playlist.playlist_name}</span>
              </label>
            </li>
          {/each}
        </ul>
        <div class="flex gap-2">
          <button
            on:click={saveSongToPlaylist}
            class="bg-[#7623ad] text-white px-4 py-2 rounded hover:bg-[#5a1a8a] transition duration-300"
          >
            Add Song
          </button>
          <button
            on:click={closePlaylistSelectionModal}
            class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600 transition duration-300"
          >
            Cancel
          </button>
        </div>
  {:else}
        <p class="mb-4">Please sign in to create playlists.</p>
        <div class="flex gap-2">
          <button
            on:click={closePlaylistSelectionModal}
            class="bg-[#7623ad] text-white px-4 py-2 rounded hover:bg-[#5a1a8a] transition duration-300"
          >
            Sign In
          </button>
          <button
            on:click={closePlaylistSelectionModal}
            class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600 transition duration-300"
          >
            Cancel
          </button>
        </div>
      {/if}
    </div>
  </div>
{/if}

<!-- PDF Generation Modal -->
{#if showPdfModal}
  <div
    class="fixed inset-0 bg-black/75 bg-opacity-80 flex justify-center items-center z-50"
    on:click={closePdfModal}
  >
    <div
      class="bg-gray-900 p-6 rounded-lg w-11/12 max-w-md"
      on:click|stopPropagation
    >
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold text-[#ffffff]">Generate PDF</h2>
        <button
          class="text-gray-400 hover:text-white text-2xl"
          on:click={closePdfModal}>&times;</button
        >
      </div>

      <div class="mb-4">
        <p class="mb-4 text-gray-300">Choose a theme for your PDF:</p>

        <div class="grid grid-cols-2 gap-4 mb-6">
          <div
            class="border rounded-lg p-4 text-center cursor-pointer transition duration-300 {selectedTheme ===
            'black'
              ? 'border-[#7623ad] bg-[#7623ad]/10'
              : 'border-gray-700'}"
            on:click={() => (selectedTheme = "black")}
          >
            <div
              class="h-24 bg-black rounded mb-2 border border-gray-700"
            ></div>
            <p class="text-gray-300">Black Theme - Good for Sharing</p>
          </div>

          <div
            class="border rounded-lg p-4 text-center cursor-pointer transition duration-300 {selectedTheme ===
            'white'
              ? 'border-[#7623ad] bg-[#7623ad]/10'
              : 'border-gray-700'}"
            on:click={() => (selectedTheme = "white")}
          >
            <div
              class="h-24 bg-white rounded mb-2 border border-gray-700"
            ></div>
            <p class="text-gray-300">White Theme - Good for Printing</p>
          </div>
        </div>

        <div class="flex justify-end gap-2">
          <button
            on:click={generatePdf}
            class="bg-[#7623ad] text-white px-4 py-2 rounded font-bold hover:bg-[#5a1a8a] transition duration-300 disabled:bg-gray-600 disabled:cursor-not-allowed"
            disabled={isGeneratingPdf}
          >
            {isGeneratingPdf ? "Generating..." : "Generate PDF"}
          </button>
          <button
            on:click={closePdfModal}
            class="bg-gray-800 text-white px-4 py-2 rounded hover:bg-gray-700 transition duration-300"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  </div>
{/if}

<!-- Share Modal -->
{#if showShareModal}
  <div
    class="fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-50"
    on:click={closeShareModal}
  >
    <div
      class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md"
      on:click|stopPropagation
    >
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold text-[#7623ad]">Share Live Session</h2>
        <button
          class="text-gray-400 hover:text-white text-2xl"
          on:click={closeShareModal}>&times;</button
        >
      </div>

      <div class="mb-4">
        <p class="mb-4 text-gray-300">
          Share this link with others to join your live session:
        </p>

        <div class="flex items-center gap-2 mb-6">
          <input
            type="text"
            value={shareLink}
            readonly
            class="flex-1 bg-gray-700 text-white px-4 py-2 rounded-lg border border-gray-600 focus:outline-none focus:border-[#7623ad]"
          />
          <button
            on:click={copyShareLink}
            class="bg-[#7623ad] text-white px-4 py-2 rounded-lg font-bold hover:bg-[#5a1a8a] transition duration-300"
          >
            {shareCopied ? "Copied!" : "Copy"}
          </button>
        </div>

        <div class="flex justify-end">
          <button
            on:click={closeShareModal}
            class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600 transition duration-300"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  </div>
  {/if}
  
  <style>
  /* Custom font for lyrics */
  @import url("https://fonts.googleapis.com/css2?family=Abel&display=swap");

    .font-abel {
      font-family: "Abel", sans-serif;
    }
  </style>
  